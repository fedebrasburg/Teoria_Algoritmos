\documentclass[a4paper,10pt]{article}

\usepackage{fullpage}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{tabulary}
\usepackage{listings}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{alltt}
\usepackage{moreverb}
\usepackage{enumitem}
\usepackage{array}
\usepackage{amssymb}
\usepackage{amsmath}



% Título principal del documento.`
\begin{document}
\title{	
	\includegraphics[scale=0.8]{images/logo-fiuba.png} \\
	\begin{center}
		\textbf{Trabajo Práctico N$^{\circ}$3} \linebreak
	\end{center}
	\begin{center}
		\begin{large}
			75.29 - Teoría de Algoritmos I \linebreak
			Facultad de Ingeniería de la Universidad de Buenos Aires \linebreak
			1er. Cuatrimestre 2017 \linebreak
		\end{large}
	\end{center} 
}
\author{	Federico Brasburg, \textit{Padrón Nro. 96.653} \\
			\texttt{ federico.brasburg.@gmail.com } \\ [2.5ex]
			Pablo Rodrigo Ciruzzi, \textit{Padrón Nro. 95.748} \\
			\texttt{ p.ciruzzi@hotmail.com } \\ [2.5ex]
			Andrés Otero, \textit{Padrón Nro. 96.604 } \\
			\texttt{ oteroandres95@gmail.com } \\ [2.5ex] \\
\\
		}
\date{23 de junio de 2017}

\maketitle
\thispagestyle{empty}

\pagebreak 

\tableofcontents
\pagebreak

\clearpage
\section{Programación Dinámica}


\subsection{Cómo correrlo}


\section{Algoritmos Randomizados}
La idea del algoritmo de contracción de Karger es encontrar el corte mínimo en un grafo $G=(V,E)$. Esto es, dos conjuntos no vacíos $A$ y $B$, donde $A \cap B = \varnothing$ y $A \cup B = V$. El tamaño del corte $(A,B)$ se define como el número de aristas $e = (u,v)$ con $u \in A$ y $v \in B$, o viceversa y lo que se busca es que éste sea mínimo.

Este algoritmo es un caso de randomización de tipo \textbf{Monte Carlo}, ya que tiene una probabilidad de que el mismo falle en encontrar la solución correcta.

El algoritmo de contracción en sí consiste en elegir una arista $e=(u,v)$ al azar, y “fusionar” los vértices creando un \textit{supernodo}, el cual tiene tiene todas las aristas de $u$ y $v$ (Salvo la arista entre ellos). Es importante recalcar que el grafo debe permitir múltiples aristas entre dos vértices, ya que al fusionar es importante que se mantengan la cantidad de aristas (Nuevamente, salvo la que es entre $u$ y $v$). Este proceso se debe repetir hasta que el grafo sólo conste de 2 vértices (Notar que en cada ``iteración'' eliminamos un nodo), los cuales se corresponderán con el corte $(A,B)$, y la cantidad de aristas en el grafo será el tamaño del mismo.

Lo más interesante de esto es que su probabilidad de falla es relativamente alta, pero puede ser reducida ampliamente mediante múltiples (en cantidad polinomial) corridas. Yendo a los números, la probabilidad de que el algoritmo sea correcto con una única corrida es de al menos ${\binom{n}{2}}^{-1}$ (con $n = |V|$), lo cual para un $n$ grande es un número muy chico (Es decir, su probabilidad de falla es como mucho $1 - {\binom{n}{2}}^{-1}$). Pero si el mismo se corre $\binom{n}{2}$ veces, se reduce a que se puede fallar en encontrar el corte mínimo con una probabilidad $(1 - {\binom{n}{2}}^{-1})^{\binom{n}{2}} \leq \frac{1}{e}$. Aún más, si se corre $\binom{n}{2}*\ln n$ veces, esta probabilidad desciende a $e^{-\ln n} = \frac{1}{n}$, lo cual es más que aceptable para un $n$ grande.

\subsection{Cómo correrlo}
Correr el algoritmo con una instancia del grafo con $n$ vértices y $2*n$ aristas es tan simple como correr \texttt{python karger.py n} desde la carpeta \texttt{src} del proyecto.

\section{Algoritmos Aproximados}
El objetivo del algoritmo es resolver el problema de optimizacion de subset-sum,dado un set de enteros positivos y t un entero positivo, encontrar la suma mas grande de enteros del set menor a t. 

La idea del algoritmo aproximado , de tiempo polinomial, viene del algoritmo que lo resuelve de manera exacta ,en tiempo exponencial. Este mismo surge de una idea de fuerza bruta , calcular la suma de todos los subset y luego elegir el mas cercano a t. Pero el algoritmo exacto lo hace de manera mas inteligente, para calcular la suma de todos los subsets ${x_1,...,x_i}$, utiliza la suma de todos los subsets${x_1,...,x_{i-1}}$ , tambien si se da cuenta que la suma de un cierto subset da mas de t lo elimina . En resumen el algoritmo exacto toma un subset $S={x_1,...,x_n}$ y el entero $t$ , luego va calculando $L_i$ , la lista de todos los subsets de ${x_1,...,x_i}$ que no superan $t$, termina devolviendo el valor mas alto de $L_n$.

Este algoritmo es exacto pero muy costoso, buscando una solucion lo suficientemente buena y menos costosa podemos usar el aproximado de tiempo polinomial. Este algoritmo ataca el problema de que calcular $L_i$ en cada paso es muy costoso, lo resuelve recortando (trimming) cada lista $L$ luego de crearla. Usando la idea de que si hay 2 valores muy cercanos en la lista no vale la pena mantenerlos a ambos. Utilizando un parametro $\delta$ de recorte , recorta todos los elemento $y$ tal que existe $z$ en la $L'$ recortada tal que : \begin{equation}
	\label{sec:delta}
 \dfrac{y} {1+\delta} \leq z \leq y \tag{3.1}
\end{equation}
Este metodo se basa en que se puede quitar muchos elemento sin que ellos queden sin ser representados en la lista recortada. El metodo de recortar la lista $L$ en $\Theta(|L|)$ , es usando la lista ordenada, agarra el primer elemento y luego va agregando los elementos mas grandes mientras no cumpla \ref{sec:delta}, la lista final es $L'$.

El algoritmo polinomico, funciona igual que el exacto pero utiliza el algoritmo de recorte luego de calcular $L_i$, que se calcula con un parametro de aproximacion $0 < \epsilon < 1$ que se usa para calcular $\delta = \dfrac{\epsilon} {2n}$ siendo $n=|S|$.



\subsection{Cómo correrlo}
 Se puede crear un problema aleatorio con el metodo $generar_problema_aleatorio$ con el nombre de archivo a generar, el tamaño $n$ del subset y dos enteros entre los cuales se generan los valores del subset .Para resolver el problema pasando  el nombre de archivo con el nombre del archivo generado, un $t$ y un parametro $\epsilon$ de aproximacion

\pagebreak

\newpage
\section{Código}
\lstset{
	language=Python, columns=flexible, breaklines=true, frame=single, title=creador\_grafos.py
}
\lstinputlisting{../src/creador_grafos.py}

\lstset{ title=grafo.py }
\lstinputlisting{../src/grafo.py}

\lstset{ title=karger.py }
\lstinputlisting{../src/karger.py}

\lstset{ title=parser.py }
\lstinputlisting{../src/parser.py}

\lstset{ title=pg.py }
\lstinputlisting{../src/pg.py}

\lstset{ title=pg\_test.py }
\lstinputlisting{../src/pg_test.py}

\lstset{ title=subset\_sum.py }
\lstinputlisting{../src/subset_sum.py}


\end{document}